{
  "hash": "256eda6d2a51dd6f8eeecd438eb26676",
  "result": {
    "markdown": "---\ntitle: \"Visualizing sort algorithms with ggplot2\"\nsubtitle: Just learning ggplot2 with inspiration from looking at Sorting Algorithms by Mike Bostock\ndate: 2015-09-25\ncategories: [ggplot2, data-visualization]\nimage: images/preview.png    \n---\n\n\n\n\nHave you read [Visualizing Algorithms](http://bost.ocks.org/mike/algorithms/) \nby Mike Bostock? It's a *pure gold post*. In that post Mike show a *static* \nrepresentation of a sort algorithm and obvious it will fun to replicate that image\nwith ggplot2 so here we go.\n\nWe need some sorts algorithms. In [this](http://faculty.cs.niu.edu/~hutchins/csci230/sorting.htm) link you can\nsee some algorithms. \n \nWe start with Insertion sort:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(viridis)\n\ntheme_set(theme_void())\n\ninsertion_sort_steps <- function(x  = sample(1:15)){\n  \n  msteps <- matrix(data = x, ncol = length(x))\n  \n  for (i in 2:length(x)) {\n    \n    j <- i\n    \n    while ((j > 1) && (x[j] < x[j - 1])) {\n      \n      temp <- x[j]\n      x[j] <- x[j - 1]\n      x[j - 1] <- temp\n      j <- j - 1\n      \n      msteps <- rbind(msteps, as.vector(x))\n      \n    }\n  }\n  \n  msteps\n  \n}\n```\n:::\n\n\nNow to test it and see what the function do:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(12345)\n\nx <- sample(seq(4))\n\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4 1\n```\n:::\n\n```{.r .cell-code}\nmsteps <- insertion_sort_steps(x)\n\nas.data.frame(msteps)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  V1 V2 V3 V4\n1  2  3  4  1\n2  2  3  1  4\n3  2  1  3  4\n4  1  2  3  4\n```\n:::\n:::\n\n\nEvery *row* is a step in sort the algorithm (a partial sort). This matrix is a hard to plot so \nwe need a nicer structure. We can transform the matrix to a *data_frame* \nwith the information of every *position* of every *element* in each *step*. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort_matix_to_df <- function(msteps){\n  \n  df <- as.data.frame(msteps, row.names = NULL)\n  \n  names(df) <- seq(ncol(msteps))\n  \n  df_steps <- df %>%\n    tbl_df() %>% \n    mutate(step = seq(nrow(.))) %>% \n    gather(position, element, -step) %>%\n    arrange(step)\n  \n  df_steps\n  \n}\n```\n:::\n\n\nAnd we apply this function to the previous *steps matrix*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_steps <- sort_matix_to_df(msteps)\n\nhead(df_steps, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n    step position element\n   <int> <chr>      <int>\n 1     1 1              2\n 2     1 2              3\n 3     1 3              4\n 4     1 4              1\n 5     2 1              2\n 6     2 2              3\n 7     2 3              1\n 8     2 4              4\n 9     3 1              2\n10     3 2              1\n```\n:::\n:::\n\n\nThe next step will be plot the data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_sort <- function(df_steps, size = 5, color.low = \"#D1F0E1\", color.high = \"#524BB4\"){\n  \n  ggplot(df_steps,\n         aes(step, position, group = element, color = element, label = element)) +  \n    geom_path(size = size, alpha = 1, lineend = \"round\") +\n    scale_colour_gradient(low = color.low, high = color.high) +\n    coord_flip() + \n    scale_x_reverse() + \n    theme(legend.position = \"none\")\n  \n}\n```\n:::\n\n\nNow compare this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(msteps)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  V1 V2 V3 V4\n1  2  3  4  1\n2  2  3  1  4\n3  2  1  3  4\n4  1  2  3  4\n```\n:::\n:::\n\n\nWith:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_sort(df_steps, size = 6) + \n  geom_text(color = \"white\", size = 4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.svg)\n:::\n:::\n\n\nIt works, so we can now scroll! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(seq(50)) %>% \n  insertion_sort_steps() %>% \n  sort_matix_to_df() %>% \n  plot_sort(size = 2.0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.svg)\n:::\n:::\n\n\nNow try with other sort algorithms:\n\nBubble sort:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbubble_sort_steps <- function(x = sample(1:15)){\n  \n  msteps <- matrix(data = x, ncol = length(x))\n  \n  for (i in 1:(length(x) - 1)) {\n    \n    for (j in 1:(length(x) - 1)) {\n      \n      if (x[j] > x[j + 1]) {\n        temp <- x[j]\n        x[j] <- x[j + 1]\n        x[j + 1] <- temp\n      }\n      \n      msteps <- rbind(msteps, as.vector(x))\n      \n    }\n  }\n  \n  msteps\n  \n}\n```\n:::\n\n\nSelection sort:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselection_sort_steps <- function(x = sample(1:15)){\n  \n  msteps <- matrix(data = x, ncol = length(x))\n  \n  for (i in 1:(length(x) - 1)) {\n    \n    smallsub <- i\n    \n    for (j in (i + 1):(length(x) - 0)) { # Is not '- 1' like website\n      \n      if (x[j] < x[smallsub]) {\n        smallsub <- j\n      }\n    }\n    \n    temp <- x[i]\n    x[i] <- x[smallsub]\n    x[smallsub] <- temp\n    \n    msteps <- rbind(msteps, as.vector(x))\n    \n  }\n  \n  msteps\n  \n}\n```\n:::\n\n\nNow test with a longer vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 50\nx <- sample(seq(n))\n\nbig_df <- rbind(\n  x %>% selection_sort_steps() %>% sort_matix_to_df() %>% mutate(sort = \"Selection Sort\"),  \n  x %>% insertion_sort_steps() %>% sort_matix_to_df() %>% mutate(sort = \"Insertion Sort\"),\n  x %>% bubble_sort_steps() %>% sort_matix_to_df() %>% mutate(sort = \"Bubble Sort\")\n)\n\nhead(big_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n   step position element sort          \n  <int> <chr>      <int> <chr>         \n1     1 1             10 Selection Sort\n2     1 2             43 Selection Sort\n3     1 3             27 Selection Sort\n4     1 4             34 Selection Sort\n5     1 5             44 Selection Sort\n6     1 6             35 Selection Sort\n```\n:::\n\n```{.r .cell-code}\nbig_df %>%\n  group_by(sort) %>% \n  summarise(steps = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  sort            steps\n  <chr>           <int>\n1 Bubble Sort    120100\n2 Insertion Sort  32100\n3 Selection Sort   2500\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  big_df,\n  aes(step, position, group = element, color = element, label = element)\n  ) +  \n  geom_path(size = 0.8, alpha = 1, lineend = \"round\") +\n  scale_colour_gradient(low = \"#c21500\", high = \"#ffc500\") + # http://uigradients.com/#Kyoto\n  facet_wrap(~sort, scales = \"free_x\", ncol = 1) +\n  theme(\n    legend.position = \"none\",\n    strip.background = element_rect(fill = \"transparent\", linetype = 0),\n    strip.text = element_text(size = 8)\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.svg)\n:::\n:::\n\n\nOr we can plot vertically using the viridis palette from the [viridis package](https://github.com/sjmgarnier/viridis) : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  big_df,\n  aes(position, step, group = element, color = element, label = element)\n  ) +  \n  geom_path(size = 1, alpha = 1, lineend = \"round\") +\n  scale_colour_gradientn(colours = viridis_pal()(n)) +\n  facet_wrap(~sort, scales = \"free_y\", nrow = 1) +\n  scale_y_reverse() +\n  theme(\n    legend.position = \"none\",\n    strip.background = element_rect(fill = \"transparent\", linetype = 0),\n    strip.text = element_text(size = 8)\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.svg)\n:::\n:::\n\n\nAnd that's it. If you write/implement another sort algorithm in this way let me know to view it ;). \n\nReferences:\n\n1. http://bost.ocks.org/mike/algorithms/\n1. http://faculty.cs.niu.edu/~hutchins/csci230/sorting.htm\n1. http://corte.si/posts/code/visualisingsorting/\n1. http://uigradients.com/#Kyoto\n1. http://algs4.cs.princeton.edu/21elementary/\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}