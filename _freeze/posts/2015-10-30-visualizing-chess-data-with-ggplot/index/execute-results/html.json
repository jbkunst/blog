{
  "hash": "8f11c520699eeaac45e16bc088f3426a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Visualizing Chess Data With ggplot\"\nsubtitle: A collection of chess visualization using only... yeah, you know! only ggplot2.\ndate: 2015-10-30\ncategories: [data-visualization, ggplot2, chess]\nimage: images/preview.png  \ncolumn: body-outset\n---\n\n\n\n\n\n\nThere are nice visualizations from chess data:\n[piece movement](http://www.visualnews.com/2015/06/15/visualizing-the-movements-of-chess-pieces-using-millions-of-games/),\n[piece survaviliy](https://github.com/ojb500/SurvivingPieces),\n[square usage by player](http://en.chessbase.com/post/seth-kadish-visualizing-chess),\netc. Sadly not always the authors shows the code/data for replicate the final result.\nSo I wrote some code to show how to do some this great visualizations entirely in\nR. Just for fun.\n\n## The Data \n\nThe original data come from [here](http://www.theweekinchess.com/chessnews/events/fide-world-cup-2015)\nwhich was parsed and stored in the [rchess](http://github.com/jbkunst/rchess) package.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(rchess)\n\ntheme_set(\n  theme_void(base_family = \"Segoe UI\") + \n    theme(legend.position = \"none\")\n  )\n\ndata(chesswc)\n\nchesswc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,266 × 11\n   event site  date       round white black result whiteelo blackelo eco   pgn  \n   <chr> <chr> <date>     <dbl> <chr> <chr> <chr>     <int>    <int> <chr> <chr>\n 1 FIDE… Khan… 2011-08-28   1.1 Kaab… Karj… 0-1        2344     2788 D15   1. d…\n 2 FIDE… Khan… 2011-08-28   1.1 Ivan… Stee… 1-0        2768     2362 E68   1. c…\n 3 FIDE… Khan… 2011-08-28   1.1 Ibra… Mame… 0-1        2402     2765 E67   1. N…\n 4 FIDE… Khan… 2011-08-28   1.1 Pono… Gwaz… 1-0        2764     2434 B40   1. e…\n 5 FIDE… Khan… 2011-08-28   1.1 Hans… Gash… 0-1        2449     2760 A61   1. d…\n 6 FIDE… Khan… 2011-08-28   1.1 Gris… Genb… 1-0        2746     2452 D37   1. d…\n 7 FIDE… Khan… 2011-08-28   1.1 De L… Radj… 0-1        2477     2744 B30   1. e…\n 8 FIDE… Khan… 2011-08-28   1.1 Kams… Di B… 1-0        2741     2480 B90   1. e…\n 9 FIDE… Khan… 2011-08-28   1.1 Lima… Svid… 1/2-1…     2493     2739 D85   1. d…\n10 FIDE… Khan… 2011-08-28   1.1 Jako… Sale… 1-0        2736     2493 B69   1. e…\n# ℹ 1,256 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nchesswc %>% \n  count(event)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  event                   n\n  <chr>               <int>\n1 FIDE World Cup 2011   398\n2 FIDE World Cup 2013   435\n3 FIDE World Cup 2015   433\n```\n\n\n:::\n\n```{.r .cell-code}\nchesswc <- chesswc %>% \n  filter(event == \"FIDE World Cup 2015\")\n```\n:::\n\n\n\n\nThe most important variable here is the [pgn](https://en.wikipedia.org/wiki/Portable_Game_Notation) game.\nThis pgn is a long string which represent the game. However this format is not so visualization\nfriendly. That's why I implemented the `history_detail()` method for a `Chess` object. Let's check.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\npgn <- sample(chesswc$pgn, size = 1)\nstr_sub(pgn, 0, 50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1. d4 Nf6 2. c4 e6 3. Nc3 Bb4 4. Nf3 b6 5. g3 Bb7 \"\n```\n\n\n:::\n:::\n\n\n\n\nCompare the previous string with the first 10 rows of the `history_detail()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchss <- Chess$new()\nchss$load_pgn(pgn)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nchss$history_detail() %>%\n  arrange(number_move)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 178 × 8\n   piece    from  to    number_move piece_number_move status number_move_capture\n   <chr>    <chr> <chr>       <int>             <int> <chr>                <int>\n 1 d2 Pawn  d2    d4              1                 1 <NA>                    NA\n 2 g8 Knig… g8    f6              2                 1 <NA>                    NA\n 3 c2 Pawn  c2    c4              3                 1 game …                  NA\n 4 e7 Pawn  e7    e6              4                 1 <NA>                    NA\n 5 b1 Knig… b1    c3              5                 1 captu…                  12\n 6 f8 Bish… f8    b4              6                 1 <NA>                    NA\n 7 g1 Knig… g1    f3              7                 1 <NA>                    NA\n 8 b7 Pawn  b7    b6              8                 1 game …                  NA\n 9 g2 Pawn  g2    g3              9                 1 <NA>                    NA\n10 c8 Bish… c8    b7             10                 1 <NA>                    NA\n# ℹ 168 more rows\n# ℹ 1 more variable: captured_by <chr>\n```\n\n\n:::\n:::\n\n\n\n\nThe result is a dataframe where each row is a piece's movement showing explicitly the cells\nwhere the travel in a particular number move. Now we apply this function over the 433\ngames in the FIDE World Cup 2015.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchesswc <- chesswc %>%\n  mutate(game_id = row_number())\n\nlibrary(furrr)\nplan(multisession, workers = 2)\n\ndfmoves <- chesswc %>% \n  select(game_id, pgn) %>% \n  mutate(\n    data = future_map(pgn, function(p) {\n      chss <- Chess$new()\n      chss$load_pgn(p)\n      chss$history_detail()\n    })\n  ) %>% select(-pgn) %>% \n  unnest()\n\n# library(doParallel)\n# workers <- makeCluster(parallel::detectCores())\n# registerDoParallel(workers)\n# moves <- plyr::llply(chesswc %>% pull(pgn), function(p) {\n#   chss <- Chess$new()\n#   chss$load_pgn(p)\n#   chss$history_detail()\n#   },  .parallel = TRUE, .paropts = list(.packages = c(\"rchess\")))\n\ndfmoves\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 41,616 × 9\n   game_id piece     from  to    number_move piece_number_move status   \n     <int> <chr>     <chr> <chr>       <int>             <int> <chr>    \n 1       1 a1 Rook   a1    c1             57                 1 <NA>     \n 2       1 a1 Rook   c1    h1             65                 2 <NA>     \n 3       1 a1 Rook   h1    h5             73                 3 <NA>     \n 4       1 a1 Rook   h5    h7             89                 4 <NA>     \n 5       1 a1 Rook   h7    e7             95                 5 captured \n 6       1 b1 Knight b1    d2             13                 1 <NA>     \n 7       1 b1 Knight d2    f1             69                 2 <NA>     \n 8       1 b1 Knight f1    e3             75                 3 captured \n 9       1 c1 Bishop c1    b2             31                 1 <NA>     \n10       1 c1 Bishop b2    c1             87                 2 game over\n# ℹ 41,606 more rows\n# ℹ 2 more variables: number_move_capture <int>, captured_by <chr>\n```\n\n\n:::\n:::\n\n\n\n\nThe `dfmoves` data frame will be the heart from all these plots due have a lot of information and \nit is easy to consume.\n\n\n## Piece Movements \n\nTo try replicate the result it's necessary the data to represent (and then plot) the\nboard. In the rchess package there are some helper functions like `chessboardata()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfboard <- rchess:::.chessboarddata() %>%\n  select(cell, col, row, x, y, cc)\n\ndfboard\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 64 × 6\n   cell  col     row     x     y cc   \n   <chr> <chr> <int> <int> <int> <chr>\n 1 a1    a         1     1     1 b    \n 2 b1    b         1     2     1 w    \n 3 c1    c         1     3     1 b    \n 4 d1    d         1     4     1 w    \n 5 e1    e         1     5     1 b    \n 6 f1    f         1     6     1 w    \n 7 g1    g         1     7     1 b    \n 8 h1    h         1     8     1 w    \n 9 a2    a         2     1     2 w    \n10 b2    b         2     2     2 b    \n# ℹ 54 more rows\n```\n\n\n:::\n:::\n\n\n\n\nNow we add this information to the `dfmoves` data frame and calculates some field to \nto know how to draw the curves (see [here](http://rpubs.com/jbkunst/geom_curve) for more details).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfpaths <- dfmoves %>%\n  left_join(\n    dfboard %>% rename(from = cell, x.from = x, y.from = y),\n    by = \"from\"\n    ) %>%\n  left_join(\n    dfboard %>% rename(to = cell, x.to = x, y.to = y) %>% select(-cc, -col, -row),\n    by = \"to\"\n    ) %>%\n  mutate(\n    x_gt_y = abs(x.to - x.from) > abs(y.to - y.from),\n    xy_sign = sign((x.to - x.from)*(y.to - y.from)) == 1,\n    x_gt_y_equal_xy_sign = x_gt_y == xy_sign)\n```\n:::\n\n\n\n\nThe data is ready! So we need now some `ggplot`, `geom_tile` for the board, the new `geom_curve`\nto represent the piece's path and some `jitter` to make this more artistic. Let's\nplot the f1 Bishop's movements.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npieces <- \"f1 Bishop\"\n\ndfpaths_piece <- dfpaths %>% \n  filter(piece == pieces)\n\nggplot() +\n  geom_tile(data = dfboard, aes(x, y, fill = cc)) +\n  geom_curve(\n    data = dfpaths_piece %>% filter(x_gt_y_equal_xy_sign),\n    aes(\n      x = x.from,\n      y = y.from,\n      xend = x.to,\n      yend = y.to\n    ),\n    position = position_jitter(width = 0.2, height = 0.2),\n    curvature = 0.50,\n    angle = -45,\n    alpha = 0.02,\n    color = \"white\",\n    size = 1.05\n  ) +\n  geom_curve(\n    data = dfpaths_piece %>% filter(!x_gt_y_equal_xy_sign),\n    aes(\n      x = x.from,\n      y = y.from,\n      xend = x.to,\n      yend = y.to\n    ),\n    position = position_jitter(width = 0.2, height = 0.2),\n    curvature = -0.50,\n    angle = 45,\n    alpha = 0.02,\n    color = \"white\",\n    size = 1.05\n  ) +\n  scale_fill_manual(values =  c(\"gray10\", \"gray20\")) +\n  ggtitle(\"f1 Bishop\") +\n  coord_equal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.svg)\n:::\n:::\n\n\n\n\nIn the same way we can plot every piece.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npieces <- c(\"White Queen\",\n            \"h1 Rook\",\n            \"b8 Knight\",\n            \"g2 Pawn\",\n            \"c1 Bishop\",\n            \"f7 Pawn\")\n\ndfpaths_pieces <- dfpaths %>% \n  filter(piece %in% pieces)\n\nggplot() +\n  geom_tile(data = dfboard, aes(x, y, fill = cc)) +\n  geom_curve(\n    data = dfpaths_pieces %>% filter(x_gt_y_equal_xy_sign),\n    aes(\n      x = x.from,\n      y = y.from,\n      xend = x.to,\n      yend = y.to\n    ),\n    position = position_jitter(width = 0.2, height = 0.2),\n    curvature = 0.50,\n    angle = -45,\n    alpha = 0.02,\n    color = \"white\",\n    size = 1.05\n  ) +\n  geom_curve(\n    data = dfpaths_pieces %>% filter(!x_gt_y_equal_xy_sign),\n    aes(\n      x = x.from,\n      y = y.from,\n      xend = x.to,\n      yend = y.to\n    ),\n    position = position_jitter(width = 0.2, height = 0.2),\n    curvature = -0.50,\n    angle = 45,\n    alpha = 0.02,\n    color = \"white\",\n    size = 1.05\n  ) +\n  scale_fill_manual(values =  c(\"gray10\", \"gray20\")) +\n  coord_equal() +\n  facet_wrap(vars(piece), ncol = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.svg)\n:::\n:::\n\n\n\n\nI think it's look very nice and similar to the original work made by [Steve Tung](https://twitter.com/_tungs_).\n\n\n## Survival Rates \n\nIn this plot we need filter `dfmoves` by `!is.na(status)` so we can know what happend with\nevery piece in at the end of the game: if a piece was caputered of or not. Then get summary \nacross all the games.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfsurvrates <- dfmoves %>%\n  filter(!is.na(status)) %>%\n  group_by(piece) %>%\n  summarize(\n    games = n(),\n    was_captured = sum(status == \"captured\")\n    ) %>%\n  mutate(surv_rate = 1 - was_captured/games)\n\ndfsurvrates %>%\n  arrange(desc(surv_rate))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 32 × 4\n   piece      games was_captured surv_rate\n   <chr>      <int>        <int>     <dbl>\n 1 Black King   433            0     1    \n 2 White King   433            0     1    \n 3 h2 Pawn      433          121     0.721\n 4 h7 Pawn      433          148     0.658\n 5 g2 Pawn      433          150     0.654\n 6 g7 Pawn      433          160     0.630\n 7 f2 Pawn      433          178     0.589\n 8 a2 Pawn      433          183     0.577\n 9 a7 Pawn      433          185     0.573\n10 f7 Pawn      433          185     0.573\n# ℹ 22 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThis helps as validation because the kings are never captured. Now we use a helper function in the\nrchess package `rchess:::.chesspiecedata()` to get the start position for every piece and then plot\nthe survival rates in the cell where the piece start in the game.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfsurvrates <- dfsurvrates %>%\n  left_join(rchess:::.chesspiecedata() %>% select(start_position, piece = name, color, unicode),\n            by = \"piece\") %>%\n  full_join(dfboard %>% rename(start_position = cell),\n            by = \"start_position\")\n\n# Auxiliar data to plot the board\ndfboard2 <- data_frame(x = 0:8 + 0.5, y = 0 + 0.5, xend = 0:8 + 0.5, yend = 8 + 0.5)\n\nggplot(dfsurvrates) +\n  geom_tile(data = dfsurvrates %>% filter(!is.na(surv_rate)),\n            aes(x, y, fill = surv_rate)) +\n  scale_fill_gradient(low = \"darkred\",  high = \"white\") +\n  geom_text(data = dfsurvrates %>% filter(!is.na(surv_rate)),\n            aes(x, y, label = scales::percent(surv_rate)),\n            color = \"gray70\", size = 3) +\n  scale_x_continuous(breaks = 1:8, labels = letters[1:8]) +\n  scale_y_continuous(breaks = 1:8, labels = 1:8)  +\n  geom_segment(data = dfboard2, aes(x, y, xend = xend, yend = yend), color = \"gray70\") +\n  geom_segment(data = dfboard2, aes(y, x, xend = yend, yend = xend), color = \"gray70\") +\n  ggtitle(\"Survival Rates for each piece\") + \n  coord_equal() + \n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.svg)\n:::\n:::\n\n\n\n\nObviously the plot show same data in text and color, and there a lot of space without\ninformation but the idea is use the chess board to represent the initial position in a chess game.\n\nWe can replace the texts with the piece's icons:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dfsurvrates) +\n  geom_tile(data = dfsurvrates %>% filter(!is.na(surv_rate)),\n            aes(x, y, fill = 100*surv_rate)) +\n  scale_fill_gradient(NULL, low = \"darkred\",  high = \"white\") +\n  geom_text(data = dfsurvrates %>% filter(!is.na(surv_rate)),\n            aes(x, y, label = unicode), size = 11, color = \"gray20\", alpha = 0.7) +\n  scale_x_continuous(breaks = 1:8, labels = letters[1:8]) +\n  scale_y_continuous(breaks = 1:8, labels = 1:8)  +\n  geom_segment(data = dfboard2, aes(x, y, xend = xend, yend = yend), color = \"gray70\") +\n  geom_segment(data = dfboard2, aes(y, x, xend = yend, yend = xend), color = \"gray70\") +\n  ggtitle(\"Survival Rates for each piece\") + \n  coord_equal() +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.svg)\n:::\n:::\n\n\n\n\n## Square Usage By Player\n\nFor this visualization we will use the `to` variable. First of all we select the player\nwho have more games in the table `chesswc`. Then for each of them get the `to` counts.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplayers <- chesswc %>% \n  count(white) %>% \n  arrange(desc(n)) %>%\n  pull(white) %>% \n  head(4)\n\nplayers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Karjakin, Sergey\" \"Svidler, Peter\"   \"Wei, Yi\"          \"Adams, Michael\"  \n```\n\n\n:::\n\n```{.r .cell-code}\ndfmov_players <- map_df(players, function(p){ # p <- sample(players, size = 1)\n  games <- chesswc %>% filter(white == p) %>% .$game_id\n  dfres <- dfmoves %>%\n    filter(game_id %in% games, !is.na(to)) %>%\n    count(to) %>%\n    mutate(player = p,\n           p = n/length(games))\n  dfres\n})\n\ndfmov_players <- dfmov_players %>%\n  rename(cell = to) %>%\n  left_join(dfboard, by = \"cell\")\n\nggplot(dfmov_players) +\n  geom_tile(aes(x, row, fill = p)) +\n  scale_fill_gradient(\"Movements to every cell\\n(normalized by number of games)\",\n                      low = \"white\",  high = \"darkblue\") +\n  geom_text(aes(x, row, label = round(p, 1)), size = 2, color = \"white\", alpha = 0.5) +\n  facet_wrap(~player) +\n  scale_x_continuous(breaks = 1:8, labels = letters[1:8]) +\n  scale_y_continuous(breaks = 1:8, labels = 1:8)  +\n  geom_segment(data = dfboard2, aes(x, y, xend = xend, yend = yend), color = \"gray70\") +\n  geom_segment(data = dfboard2, aes(y, x, xend = yend, yend = xend), color = \"gray70\") +\n  coord_equal() +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.svg)\n:::\n:::\n\n\n\n\n## Distributions For The First Movement \n\nNow, with the same data and using the `piece_number_move` and `number_move` we can obtain\nthe distribution for the first movement for each piece.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npiece_lvls <- rchess:::.chesspiecedata() %>%\n  mutate(col = str_extract(start_position, \"\\\\w{1}\"),\n         row = str_extract(start_position, \"\\\\d{1}\")) %>%\n  arrange(desc(row), col) %>%\n  pull(name)\n\ndfmoves_first_mvm <- dfmoves %>%\n  mutate(piece = factor(piece, levels = piece_lvls),\n         number_move_2 = ifelse(number_move %% 2 == 0, number_move/2, (number_move + 1)/2 )) %>%\n  filter(piece_number_move == 1)\n\nggplot(dfmoves_first_mvm) +\n  geom_density(aes(number_move_2), fill = \"#B71C1C\", alpha = 0.8, color = NA) +\n  scale_y_continuous(breaks = NULL) +\n  scale_x_continuous(breaks = c(0, 20, 40), limits = c(0, 40)) + \n  facet_wrap(~piece, nrow = 4, ncol = 8, scales = \"free_y\")  +\n  labs(x = \"Number Move\", y = \"Density\") +\n  theme_minimal(base_size = 7) +\n  theme(strip.text = element_text(hjust = 0))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.svg)\n:::\n:::\n\n\n\n\nNotice the similarities between the White King and h1 Rook due the castling, the same\neffect is present between the Black King and the h8 Rook.\n\n\n## Who Captures Whom \n\nFor this plot we'll use the igraph package and [ForceAtlas2](https://github.com/analyxcompany/ForceAtlas2)\npackage an R implementation by [Adolfo Alvarez](http://adolfoalvarez.cl) of the Force Atlas 2 graph layout\ndesigned for Gephi.\n\nWe get the rows with `status == \"captured\"` and summarize by `piece` and `captured_by` variables. The result data\nframe will be the edges in our igraph  object using the `graph.data.frame` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\n\n# devtools::install_github(\"analyxcompany/ForceAtlas2\")\nlibrary(ForceAtlas2)\n\ndfcaputures <- dfmoves %>%\n  filter(status == \"captured\") %>%\n  count(captured_by, piece) %>%\n  ungroup() %>% \n  arrange(desc(n)) %>% \n  filter(!is.na(captured_by))\n\ndfvertices <- rchess:::.chesspiecedata() %>%\n  select(-fen, -start_position) %>%\n  mutate(name2 = str_replace(name, \" \\\\w+$\", unicode),\n         name2 = str_replace(name2, \"White|Black\", \"\"))\n\ng <- graph.data.frame(dfcaputures %>% select(captured_by, piece, weight = n),\n                      directed = TRUE,\n                      vertices = dfvertices)\n\nset.seed(123)\n# lout <- layout.kamada.kawai(g)\nlout <- layout.forceatlas2(g, iterations = 10000, plotstep = 0)\n\ndfvertices <- dfvertices %>%\n  mutate(x = lout[, 1], y = lout[, 2])\n\ndfedges <- as_data_frame(g, \"edges\") %>%\n  tibble::as_tibble() %>%\n  left_join(dfvertices %>% select(from = name, x, y), by = \"from\") %>%\n  left_join(dfvertices %>% select(to = name, xend = x, yend = y), by = \"to\")\n```\n:::\n\n\n\n\nTo plot the the network I prefer use ggplot2 instead igraph just you get more control in the style\nand colors.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_curve(data = dfedges %>%\n               filter((str_extract(from, \"\\\\d+\") %in% c(1, 2) |\n                         str_detect(from, \"White\"))),\n             aes(x, y, xend = xend, yend = yend, alpha = weight, size = weight),\n             curvature = 0.1, color = \"red\") +\n  geom_curve(data = dfedges %>%\n               filter(!(str_extract(from, \"\\\\d+\") %in% c(1, 2) |\n                          str_detect(from, \"White\"))),\n             aes(x, y, xend = xend, yend = yend, alpha = weight, size = weight),\n             curvature = 0.1, color = \"blue\") +\n  scale_alpha(range = c(0.01, 0.5)) +\n  scale_size(range = c(0.01, 2)) +\n  geom_point(data = dfvertices, aes(x, y, color = color), size = 13, alpha = 0.9) +\n  scale_color_manual(values = c(\"gray10\", \"gray90\")) +\n  geom_text(data = dfvertices %>% filter(str_length(name2) != 1),\n            aes(x, y, label = name2), size = 5, color = \"gray50\") +\n  geom_text(data = dfvertices %>% filter(str_length(name2) == 1),\n            aes(x, y, label = name2), size = 5, color = \"gray50\") +\n  ggtitle(\"Red: white captures black | Blue: black captures white\") +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.svg)\n:::\n:::\n\n\n\n\nIt's know we usually exchange pieces with the same values: queen by queen, knight by bishop, etc. The interesting\nfact we see here is the d2 pawn/c7 pawn/g1 knight relationship because d2 pawn/c7 pawn is not so symmetrical and \nit's explained by the popular use the \n[Sicilian Opening](https://en.wikibooks.org/wiki/Chess_Opening_Theory/1._e4/1...c5/2._Nf3/2...d6/3._d4/3...cxd4/4._Nxd4) \nin a master level (`1.e4 c5 2.Nf3 d6 3.d4 cxd4 4.Nxd4`).\n\nI hope you enjoyed this post in the same way I enjoyed doing it :D. If you notice a mistake please let me know.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}